options{  JDK_VERSION = "1.5";  static = false;}PARSER_BEGIN(Parser)package org.mmaroti.ua.cspgen;import java.io.*;

public class Parser{	public static void main(String args []) throws ParseException, IOException	{		FileInputStream is = new FileInputStream("Sample.txt");		Parser parser = new Parser(is);		parser.Start();	}}PARSER_END(Parser)SKIP :{	" "|	"\t"|	"\r"}TOKEN :{	< EOL : "\n" >|	< VARIABLE : "variable" >|	< OPERATION : "operation" >|	< SIZE : "size" >|	< ARITY : "arity" >|	< CONSTANT : "constant" >|	< VALUE : "value" >|	< RELATION : "relation" >|	< CONSTRAINT : "constraint" >}TOKEN :{	< AND : "&" >|	< OR : "|" >|	< NOT : "!" >|	< IMPLIES : "->" >|	< EQUALS : "=" >|	< NOTEQUALS : "!=" | "<>" >|	< LESSTHAN : "<" >|	< LESSTHANEQUALS : "<=" >}TOKEN :{	< #LETTER : ["a"-"z", "A"-"Z", "_"] >|	< #DIGIT : ["0"-"9"] >|	< NUMBER : (<DIGIT>)+ >|	< NAME : <LETTER> (<LETTER> | <DIGIT>)* >|	< LPAR : "(" >|	< RPAR : ")" >}void Start() : { }{	(Command() <EOL>)* 	<EOF>}void Constant() : { }{	<NUMBER> | <NAME>}void Command() : { }{	<CONSTANT> <NAME> [ <VALUE> ] <NUMBER>	{		System.out.println("constant");	}|	<VARIABLE> <NAME> [ <SIZE> ] Constant()|	<OPERATION> <NAME> [ <ARITY> ] Constant() [ <SIZE> ] Constant()   	{		System.out.println("operation");	}|	<RELATION> <NAME> [ <ARITY> ] Constant() [ <SIZE> ] Constant()   	{		System.out.println("relation");	}|	<CONSTRAINT> LogicalExpression()|	{ }	// empty line}void LogicalExpression() : { }{	LogicalOrExpression() [ <IMPLIES> LogicalOrExpression() ]}void LogicalOrExpression() : { }{	LogicalAndExpression() [ <OR> LogicalOrExpression() ]}void LogicalAndExpression() : { }{	LogicalNotExpression() [ <AND> LogicalAndExpression() ]}void LogicalNotExpression() : { }{	( <NOT> )* LogicalAtomicExpression()}void LogicalAtomicExpression() : { }{	"(" LogicalExpression() ")"|	AtomicExpression() [ Comparator() AtomicExpression() ]}void Comparator() : { }{	<EQUALS>|	<NOTEQUALS>|	<LESSTHAN>|	<LESSTHANEQUALS>}void AtomicExpression() : { }{	LOOKAHEAD(<NAME> <LPAR>) <NAME> <LPAR> ListExpression() <RPAR>|	<NAME>}void ListExpression() : { }{	AtomicExpression() ( "," AtomicExpression() )*|	{ }	// empty list}