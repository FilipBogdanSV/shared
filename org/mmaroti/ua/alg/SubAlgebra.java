/**
 *	Copyright (C) Miklos Maroti, 2004-2005
 *
 * This program is free software; you can redistribute it and/or modify it 
 * under the terms of the GNU General Public License as published by the 
 * Free Software Foundation; either version 2 of the License, or (at your 
 * option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General 
 * Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along 
 * with this program; if not, write to the Free Software Foundation, Inc., 
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

package org.mmaroti.ua.alg;

import org.mmaroti.ua.util.*;
import org.mmaroti.ua.set.*;

public class SubAlgebra extends Algebra
{
	protected SubUniverse universe;

	public Universe getUniverse()
	{
		return universe;
	}
	
	/**
	 * Constructs a new empty subuniverse of the
	 * provided base algebra.
	 */
	public SubAlgebra(Algebra base)
	{
		universe = new SubUniverse(base.getUniverse());
		
		Operation[] operations = base.getOperations(); 

		this.operations = new Op[operations.length];
		for(int i = 0; i < operations.length; ++i)
			this.operations[i] = new Op(operations[i]);
	}

	/**
	 * Generates new elements in this subalgera.
	 *
	 * @param maxSize the maximum number of elements this subset should have.
	 * If Integer.MAX_VALUE is specified, then the whole subalgebra is generated.
	 */
	public void generate(int maxSize)
	{
		if( universe.getSize() >= maxSize )
			return;
			
		int radius = -1;
		while( ++radius <= universe.getSize() )
		{
			for(int i = 0; i < operations.length; ++i)
			{
				Op op = operations[i];
				SphereArgument arg = new SphereArgument(op.getSymbol().arity, radius);
				int[] iargs = arg.vector;
				Object[] oargs = op.os;
				
				if( arg.reset() ) 
				do
				{
					for(int j = 0; j < iargs.length; ++j)
						oargs[j] = universe.getElement(iargs[j]);

					universe.add(op.base.getValue(oargs));
					if( universe.getSize() >= maxSize )
						return;
		
				} while( arg.next() );
			}
		}
	}

	/**
	 * Adds the specified element to the subalgebra. The 
	 */
	public void add(Object object)
	{
		universe.add(object);
	}
	
	/**
	 * Calculates the subalgebra generated by the contained elements.
	 */
	public void generate()
	{
		generate(Integer.MAX_VALUE);
	}

	/**
	 * The operations of the subalgebra
	 */
	protected Op[] operations;
	
	public Operation[] getOperations()
	{
		return operations;
	}
	
	protected class Op extends Operation
	{
		/**
		 * The operation of the enclosing algebra
		 */
		protected Operation base;

		/**
		 * Static vector of integers holding the transformed 
		 * indices.
		 */
		protected Object[] os;
		
		protected Op(Operation op)
		{
			this.base = op;
			this.os = new Object[op.getSymbol().arity];
		}
		
		public Universe getUniverse()
		{
			return universe;
		}

		public Symbol getSymbol()
		{
			return base.getSymbol();
		}

		public Object getValue(Object[] args)
		{
			return base.getValue(args);
		}

		public int getValue(int[] args)
		{
			for(int i = 0; i < os.length; ++i)
				os[i] = universe.getElement(args[i]); 

			return universe.getIndex(base.getValue(os));
		}
	}
}	
